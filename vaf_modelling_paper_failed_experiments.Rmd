---
title: "The Natural History and Fitness Landscape of Clonal Haematopoiesis"
subtitle: "Failed pieces of analysis"
author: 
    - Jos√© Guilherme de Almeida
    - Moritz Gerstung
output: 
  html_document:
    theme: lumen
    highlight: tango
    code_folding: hide
    df_print: paged
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r import_functions, include=FALSE}
source("scripts/vaf_dynamics_functions.R")
set.seed(42)
```

```{r loading_data}
load(file = "vaf_modelling_coefficients.Rdata")
values_model_f2 <- readRDS(file = "models/model_F2_full.RDS")
source("scripts/prepare_data.R")
```

### Multidimensional trajectories 

Here, we try to understand whether we should expect blood parameter trajectories to be multidimensional - are changes between timepoints associated in any way? To do so, we characterise each parameter that is fully available for most individuals in at least 3 timepoints using an $(n-1)$-degree polynomial, where $n$ is the number of timepoints for that parameter. 

As such, we avoid missing values by first removing individuals with over 10 missing values. Then, for for each parameter we remove phases with missing values.

```{r, fig.width=5,fig.height=5,dpi=300}
data_multidimensional_trajectories_raw <- load_blood_count_data() %>% 
  subset(!(SardID %in% c(load_excluded_individuals(),load_excluded_individuals_lymph()))) %>% 
  mutate(
    NEUT = WBC * NEUT_PERC/100,
    MONO = WBC * MONO_PERC/100,
    LYMPH = WBC * LYMPH_PERC/100,
    BASO = WBC * BASO_PERC/100,
    EOS = WBC * EOS_PERC/100
  ) %>%
  select(SardID,Phase,
         HB,MCV,MCH,NEUT,LYMPH,MONO,EOS,BASO,
         PLT,ESR)

allphases_dataset <- data_multidimensional_trajectories_raw %>% 
  merge(distinct(select(load_data(),SardID,Phase,Age)),by = c("SardID","Phase")) %>%
  gather(key = 'key',value = 'value',-Phase,-SardID) %>% 
  filter(!is.na(value)) %>% 
  spread(key = Phase,value = value) %>% 
  group_by(SardID) %>% 
  filter(sum(c(is.na(`1`),is.na(`2`),is.na(`3`),is.na(`4`),is.na(`5`))) == 0) %>% 
  gather(key = "Phase",value = "value",-SardID,-key) %>%
  spread(key,value) %>%
  gather("key","value",-SardID,-Phase,-Age)

first_four_phases_dataset <- data_multidimensional_trajectories_raw %>%
  filter(Phase != 5) %>% 
  merge(distinct(select(load_data(),SardID,Phase,Age)),by = c("SardID","Phase")) %>% 
  gather(key = 'key',value = 'value',-Phase,-SardID) %>% 
  filter(!is.na(value)) %>% 
  spread(key = Phase,value = value) %>% 
  group_by(SardID) %>% 
  filter(sum(c(is.na(`1`),is.na(`2`),is.na(`3`),is.na(`4`))) == 0) %>%
  gather(key = "Phase",value = "value",-SardID,-key) %>%
  spread(key,value) %>%
  gather("key","value",-SardID,-Phase,-Age)

poly_time <- function(df) {
  output_list <- list()
  sard_ids <- unique(df$SardID)
  keys <- unique(df$key)
  idx <- 0 
  for (x in keys) {
    big_s <- df %>%
      subset(key == x)
    n <- length(unique(big_s$Phase)) - 1
    for (y in sard_ids) {
      idx <- idx + 1
      s <- big_s %>%
        subset(SardID == y) 
      output_list[[idx]] <- c(lm(s$value ~ poly(s$Age,n))$coefficients,
                              x,y)
    }
  }
  output <- do.call(rbind,output_list) %>%
    as.data.frame()
  output[,1:(n+1)] <- apply(output[,1:(n+1)],2,as.numeric)
  colnames(output) <- c("Intercept",paste("polynomial_coefficient",seq(1,n),sep='_'),"key","SardID")
  output <- output %>% gather("feature","value",-key,-SardID) %>%
    spread(key,value)
  output <- output$feature %>% unique %>% sapply(function(x) output[output$feature == x,],simplify = F)
  output <- names(output) %>% lapply(function(x) {
    tmp <- output[x][[1]] %>%
      select(-feature)
    colnames(tmp)[2:ncol(tmp)] <- paste(colnames(tmp)[2:ncol(tmp)],x,sep = '_')
    return(tmp)
  }) %>% reduce(full_join,by = "SardID")
  return(output)
}

output <- poly_time(first_four_phases_dataset)

output_with_coefficients <- merge(
  output,
  r_values %>%
    select(SardID = individual,coefficient,b_clone) %>%
    group_by(SardID) %>%
    summarise(MaxGeneticCoefficient = max(coefficient),
              MaxCloneCoefficient = max(b_clone+coefficient)) %>%
    distinct(),
  by = 'SardID',
  all.x = T
) %>% 
  mutate(MaxGeneticCoefficient = ifelse(is.na(MaxGeneticCoefficient),0,MaxGeneticCoefficient),
         MaxCloneCoefficient = ifelse(is.na(MaxCloneCoefficient),0,MaxCloneCoefficient))

two_dim <- output_with_coefficients[,-c(1,ncol(output_with_coefficients) - c(1,0))] %>% 
  scale %>% 
  dist() %>%
  sammon()

points <- two_dim$points[,c(1,2)]
colnames(points) <- c("X1","X2")

ggplot(
  data.frame(points,
             genetic=output_with_coefficients$MaxGeneticCoefficient,
             clone=output_with_coefficients$MaxCloneCoefficient),
  aes(x = X1,y = X2,color = clone)) + 
  #geom_density2d() + 
  geom_point(size = 1) + 
  theme_minimal() + 
  xlab("Principal coordinate 1") + 
  ylab("Principal coordinate 2") + 
  theme(legend.position = "bottom") +
  scale_color_material()
```

```{r}
cluster_centers <- kmeans(scale(output_with_coefficients[,-c(1,ncol(output_with_coefficients) - c(1,0))]),2)
cluster_dynamics <- data.frame(
  MaxGeneticCoefficient = output_with_coefficients$MaxGeneticCoefficient,
  MaxCloneCoefficient = output_with_coefficients$MaxCloneCoefficient,
  cluster = factor(cluster_centers$cluster))
ggplot(cluster_dynamics,aes(x = cluster,
                            y = MaxCloneCoefficient,
                            group = cluster)) + 
  geom_boxplot() + 
  geom_signif(comparisons = list(c("1","2"))) + 
  theme_minimal()
```

### Predicting CH from blood count trajectories

One practical application of this work can also consider assessing if the progression of blood count or chemistry parameters for each individual and see how this can be used to predict the presence of large clones. As an initial exercise we use the slopes of each parameter as a linear progression to do this.

```{r predicting CH}
slope <- function(x,y) {
  df <- data.frame(
    x=x,
    y=y
  ) %>%
    na.omit
  return((sum(df$x * df$y) - sum(df$x) * sum(df$y)) / (sum(df$x^2) - sum(df$x)^2))
}

trajectory_class_data_wide <- trajectory_class_data %>%
  spread(key = Parameter,value = class) 
trajectory_class_data_wide[,c(3,4,5,6)] <- as_tibble(apply(trajectory_class_data_wide[,c(3,4,5,6)],2,as.numeric) - 1)
colnames(trajectory_class_data_wide) <- c("SardID","N","ESR_traj","WBC_traj","Hb_traj","Plt_traj")

individual_linear_trajectories <- complete_blood_counts_lcmm %>% 
  select(SardID,Age,HB,WBC,PLT,MCV,UricAcid,ESR,MinAge,Gender) %>% 
  distinct() %>%
  group_by(SardID) %>%
  summarise(Hb = slope(HB,Age),
            WBC = slope(WBC,Age),
            Plt = slope(PLT,Age),
            ESR = slope(ESR,Age),
            MCV = slope(MCV,Age),
            UricAcid = slope(UricAcid,Age),
            MinAge = MinAge[1],
            Gender = Gender[1]) %>%
  merge(trajectory_class_data_wide,by="SardID")

largest_clone_size <- complete_blood_counts_lcmm %>%
  select(SardID,Age,VAF) %>%
  group_by(SardID) %>%
  summarise(LargestClone = max(VAF[Age == max(Age)])) %>%
  mutate(LargestCloneBinary = LargestClone >= 0.05) %>%
  mutate(LargestClone = log(LargestClone))

fastest_growing_clone <- r_values %>%
  group_by(SardID = individual) %>%
  summarise(FastestClone_genetic = log(max(coefficient)),
            FastestClone = log(max(coefficient + b_clone)))

blood_clones <- merge(
  individual_linear_trajectories,
  largest_clone_size,
  by = "SardID"
) %>%
  merge(fastest_growing_clone,
        by = "SardID")
blood_clones <- blood_clones[is.finite(rowSums(blood_clones[,c(2:7,13:15)])),] %>%
  mutate(Male = Gender == 'M',
         Female = Gender == 'F') 

train_idxs <- sample(1:nrow(blood_clones),round(nrow(blood_clones)/2),replace = F)
train_set <- blood_clones[train_idxs,]
test_set <- blood_clones[-train_idxs,]

lambda_df <- list()
for (i in 1:10) {
  M <- cv.glmnet(
    x = as.matrix(select(train_set,Hb,WBC,Plt,ESR,MCV,UricAcid,MinAge,Male)),
    y = as.matrix(select(train_set,LargestCloneBinary)),
    nfolds=10,
    alpha = 0.5,
    type.measure="auc",
    family= 'binomial',
    keep = T) 
  lambda_df[[i]] <- data.frame(lambda_value = M$lambda,
                               score = M$cvm,
                               fold = i)
}
lambda_df <- do.call(what=rbind,lambda_df) %>%
  group_by(lambda_value) %>%
  summarise(score.mean = mean(score),
            score.std = sd(score))
best_lambda <- lambda_df$lambda_value[which.max(lambda_df$score.mean)]
best_lambda

M <- glmnet(
  x = as.matrix(select(train_set,Hb,WBC,Plt,ESR,MCV,UricAcid,MinAge,Male)),
  y = as.matrix(select(train_set,LargestCloneBinary)),
  lambda = best_lambda,
  type.measure="auc",
  family= 'binomial',
  alpha=0.01,
  keep = T
)

coefplot::coefplot(M)

pROC::roc(predictor=predict(M,newx = as.matrix(select(test_set,Hb,WBC,Plt,ESR,MCV,UricAcid,MinAge,Male))),
          response=unlist(select(test_set,LargestCloneBinary)))
```
This approach works poorly ($AUC_{test} < 0.6$). This may be associated with how we are characterising the dynamics of blood count and chemistry parameters - using a linear slope may fail to capture this. As such, we use in the following code block functional data analysis (FDA) as implemented in the `fda.usc` package. FDA is concerned with the analysis of functional data - curves - in both univariate and multivariate settings. As such, it provides ways of charaterising in a quantitative manner the different trajectories associated with blood count parameters. 

```{r FDA_CH}
NFolds <- 5
last_timepoint <- 4

functional_data_list <- list()
sard_ids <- sort(unique(complete_blood_counts_lcmm$SardID))
largest_clones_binary <- largest_clone_size$LargestCloneBinary[match(largest_clone_size$SardID,sard_ids)]
largest_clones_log <- largest_clone_size$LargestClone[match(largest_clone_size$SardID,sard_ids)]
fastest_clones <- fastest_growing_clone$FastestClone[match(largest_clone_size$SardID,sard_ids)]

for (parameter in c("HB","PLT","WBC","ESR","MCV","Triglycerides","HDLcholesterol","UricAcid","Age")) {
  X <- sard_ids %>% 
    lapply(function(x) {
      sub_df <- complete_blood_counts_lcmm[complete_blood_counts_lcmm$SardID == x,] 
      sub_df <- sub_df[,c("Phase",parameter)] %>%
        distinct %>%
        arrange(Phase)
      phase <- sub_df$Phase
      output <- rep(NA,5)
      output[c(1:5) %in% c(phase)] <- unlist(sub_df[,parameter])
      return(output)
    }) %>%
    do.call(what = cbind) %>%
    t %>%
    as.data.frame
  colnames(X) <- c("TP_1","TP_2","TP_3","TP_4","TP_5")
  
  functional_data_list[[parameter]] <- X
}

functional_data_list <- functional_data_list %>%
  lapply(
    function(x) return(x[,1:last_timepoint])
  )

idx_complete <- lapply(functional_data_list,function(x){
  !is.na(rowSums(x))
}) %>% 
  do.call(what = cbind) %>%
  apply(1,prod) %>%
  as.logical()

partitions_negative <- sample(1:NFolds, size=sum(largest_clones_binary[idx_complete]==F), replace = TRUE)
partitions_positive <- sample(1:NFolds, size=sum(largest_clones_binary[idx_complete]==T), replace = TRUE)
partitions <- rep(0,sum(idx_complete))
partitions[largest_clones_binary[idx_complete] == T] <- partitions_positive
partitions[largest_clones_binary[idx_complete] == F] <- partitions_negative

cv_sets<- list()
for (i in 1:NFolds) {
  print(paste("Fold",i))
  obs_train <- largest_clones_binary[idx_complete][partitions != i]
  obs_train_cont <- largest_clones_log[idx_complete][partitions != i]
  obs_train_speed <- as.numeric(fastest_clones[idx_complete][partitions != i])
  obs_test <- largest_clones_binary[idx_complete][partitions == i]
  obs_test_cont <- largest_clones_log[idx_complete][partitions == i]
  obs_test_speed <- as.numeric(fastest_clones[idx_complete][partitions == i])
  
  fdata_training <- functional_data_list %>%
    lapply(function(x) {
      fdata(x[idx_complete,][partitions != i,])
    })
  fdata_training_t <- fdata_training %>%
    lapply(function(x) x[obs_train == T,])
  fdata_training_f <- fdata_training %>%
    lapply(function(x) x[obs_train == F,])

  fdata_testing <- functional_data_list %>%
    lapply(function(x) {
      fdata(x[idx_complete,][partitions == i,])
    })
  
  ages_training <- fdata_training$Age
  ages_testing <- fdata_testing$Age
  
  fdata_training$Age <- NULL
  fdata_training_t$Age <- NULL
  fdata_training_f$Age <- NULL
  fdata_testing$Age <- NULL
  
  multi_variate_fn <- list("depth.FMp",
                           "depth.modep",
                           "depth.RPp")
  mono_variate_fn <- list("depth.FM",
                          "depth.mode",
                          "depth.RP")
  
  mv_features_training <- multi_variate_fn %>% 
    lapply(
      function(x) {
        fn_name <- x
        x <- get(x)
        tmp <- data.frame(
          full = x(fdata_training,fdata_training)$dep,
          true = x(fdata_training,fdata_training_t)$dep,
          false = x(fdata_training,fdata_training_f)$dep
        ) 
        colnames(tmp) <- paste(substr(fn_name,7,nchar(fn_name)),
                               colnames(tmp),
                               sep='.')
        tmp %>%
          return
      }
    ) %>% 
    do.call(what=cbind)

  monov_features_training <- mono_variate_fn %>%
    lapply(
      function(x) {
        fn_name <- x
        x <- get(x)
        tmp <- lapply(names(fdata_training),function(y) {
          data.frame(
            full = x(fdata_training[[y]],fdata_training[[y]])$dep,
            true = x(fdata_training[[y]],fdata_training_t[[y]])$dep,
            false = x(fdata_training[[y]],fdata_training_f[[y]])$dep
        ) %>%
          return
        }) %>%
        do.call(what=cbind)
        colnames(tmp) <- 
          paste(
            substr(fn_name,7,nchar(fn_name)),
            rep(names(fdata_training),each=3),
            colnames(tmp),
            sep='.'
          )
        return(tmp)
      }
    ) %>% 
    do.call(what=cbind)

  mv_features_testing <- multi_variate_fn %>% 
    lapply(
      function(x) {
        fn_name <- x
        x <- get(x)
        tmp <- data.frame(
          full = x(fdata_testing,fdata_training)$dep,
          true = x(fdata_testing,fdata_training_t)$dep,
          false = x(fdata_testing,fdata_training_f)$dep
        ) 
        colnames(tmp) <- paste(substr(fn_name,7,nchar(fn_name)),
                               colnames(tmp),
                               sep='.')
        tmp %>%
          return
      }
    ) %>% 
    do.call(what=cbind)

  monov_features_testing <- mono_variate_fn %>%
    lapply(
      function(x) {
        fn_name <- x
        x <- get(x)
        tmp <- lapply(names(fdata_testing),function(y) {
          data.frame(
            full = x(fdata_testing[[y]],fdata_training[[y]])$dep,
            true = x(fdata_testing[[y]],fdata_training_t[[y]])$dep,
            false = x(fdata_testing[[y]],fdata_training_f[[y]])$dep
        ) %>%
          return
        }) %>%
        do.call(what=cbind)
        colnames(tmp) <- 
          paste(
            substr(fn_name,7,nchar(fn_name)),
            rep(names(fdata_testing),each=3),
            colnames(tmp),
            sep='.'
          )
        return(tmp)
      }
    ) %>% 
    do.call(what=cbind)
  
  slopes_training <- fdata_training %>%
    lapply(function(x) {
      return(
        sapply(1:nrow(x),
               function(y) {
                 return(slope(ages_training$data[y,],x$data[y,]))
               })
      )
    }) %>%
    do.call(what = cbind)
  colnames(slopes_training) <- paste("slope",
                                     colnames(slopes_training),sep='.')
  
  slopes_testing <- fdata_testing %>%
    lapply(function(x) {
      return(
        sapply(1:nrow(x),
               function(y) {
                 return(slope(ages_testing$data[y,],x$data[y,]))
               })
      )
    }) %>%
    do.call(what = cbind)
  colnames(slopes_testing) <- paste("slope",
                                    colnames(slopes_testing),sep='.')
  
  cv_sets[[i]] <- list(
    obs_train = obs_train,
    obs_train_cont = obs_train_cont,
    obs_train_speed = obs_train_speed,
    obs_test = obs_test,
    obs_test_cont = obs_test_cont,
    obs_test_speed = obs_test_speed,
    fdata_training = fdata_training,
    fdata_testing = fdata_testing,
    features_training = cbind(mv_features_training,
                              monov_features_training,
                              slopes_training),
    features_testing = cbind(mv_features_testing,
                             monov_features_testing,
                             slopes_testing)
    )
}
```

```{r FDA_CH_prediction}
pred_metrics <- function(obs,prob,threshold = 0.5) {
  rocurve <- pROC::roc(obs,prob)
  aucurve <- pROC::auc(rocurve)
  
  pred <- prob >= threshold
  tp <- sum((pred == 1) & (pred == obs))
  fp <- sum((pred == 1) & (pred != obs))
  tn <- sum((pred == 0) & (pred == obs))
  fn <- sum((pred == 0) & (pred != obs))
  tw <- length(obs) - sum(obs == 1)
  nw <- length(obs) - sum(obs == 0)
  
  return (
    c(
      tp = tp,fp = fp, tn = tn, fn = fn,
      sens = tp / (tp + fn),
      spec = tn / (tn + fp),
      prec = tp / (tp + fp),
      auc = pROC::auc(pROC::roc(obs,prob)),
      f1score = 2 * tp / (2 * tp + fp + fn),
      acc = (tp+tn)/(tp + tn + fp + fn),
      wacc = (tp*tw+tn*nw)/(tp*tw+tn*nw+fp*tw+fn+nw)
    )
  )
}

cv_models <- cv_sets %>% 
  lapply(
    function(x) {
      features_training <- x$features_training
      obs_train <- x$obs_train
      features_testing <- x$features_testing
      obs_test <- x$obs_test
      features_training <- select(
        features_training,
        colnames(features_training)[!grepl('full',colnames(features_training))])
      features_testing <- select(
        features_testing,
        colnames(features_testing)[!grepl('full',colnames(features_testing))])
  
  
      weights <- table(obs_train)
      weights <- sum(weights) / weights
      weights <- sqrt(weights[match(obs_train,names(weights))])
      
      fda.model <- cv.glmnet(
        x = as.matrix(features_training),
        y = obs_train,
        type.measure = "auc",
        family = "binomial",
        nfolds = 5,
        weights = weights
      )
      
      pred_training <- predict(fda.model,
                               as.matrix(features_training),
                               type = 'response'
                               )
      pred_testing <- predict(fda.model,
                              as.matrix(features_testing),
                              type = 'response'
                              )
      
      return(
        list(pred_training = pred_training,
             pred_testing = pred_testing,
             obs_training = obs_train,
             obs_testing = obs_test,
             model = fda.model)
      )
      }
  )

cv_models %>%
  sapply(
    function(x) {
      threshold <- pROC::coords(pROC::roc(x$obs_training,x$pred_training),
                                "best",
                                ret='threshold') %>%
        unlist
      pred_metrics(x$obs_testing,
                   x$pred_testing,
                   threshold)
    }
  )
```

While offering, in theory, a better characterisation of curves, FDA does not seem to provide any form of characterisation that would allow us to classify CH size or speed from the trajectories of individuals. The most likely cause for this is that these trajectories are not enough to predict the presence or dynamics of clones. A possible reason for this is that the changes that CH effects are not large enough to cause detectable changes in blood count or chemistry parameter trajectories.
